from __future__ import annotationsimport mathimport commands2import wpimathimport wpilibimport typingfrom commands2 import cmd, InstantCommand, RunCommand, WaitCommandfrom commands2.button import CommandGenericHIDfrom rev import LimitSwitchConfigfrom wpilib import XboxControllerfrom wpimath.controller import PIDController, ProfiledPIDControllerRadians, HolonomicDriveControllerfrom wpimath.geometry import Pose2d, Rotation2d, Translation2dfrom wpimath.trajectory import TrajectoryConfig, TrajectoryGeneratorfrom commands.approach import ApproachTagfrom commands.intakecommands import IntakeFeedGamepieceForward, IntakeGamepiece, IntakeEjectGamepieceBackwardfrom constants import AutoConstants, DriveConstants, OIConstants, LiftConstants, IntakeConstantsfrom subsystems.drivesubsystem import DriveSubsystemfrom subsystems.elevator import Elevatorfrom subsystems.intake import Intakefrom subsystems.limelight_camera import LimelightCamerafrom subsystems.singleIntake import SingleIntakefrom commands.reset_xy import ResetXY, ResetSwerveFrontfrom commands.aimtodirection import AimToDirectionfrom commands.alignwithtag import AlignWithTagfrom commands.arcadedrive import ArcadeDrivefrom commands.elevatorposition import SetElevatorPositionfrom commands.findobject import FindObjectfrom commands.followobject import FollowObject, StopWhenfrom commands.gotopoint import GoToPointfrom commands.holonomicdrive import HolonomicDrivefrom commands.jerky_trajectory import JerkyTrajectoryfrom commands.reset_xy import ResetXYfrom commands.setcamerapipeline import SetCameraPipelinefrom commands.swervetopoint import SwerveToPoint, SwerveToSide, SwerveMoveimport commands.intakecommandsclass RobotContainer:    """    This class is where the bulk of the robot should be declared. Since Command-based is a    "declarative" paradigm, very little robot logic should actually be handled in the :class:`.Robot`    periodic methods (other than the scheduler calls). Instead, the structure of the robot (including    subsystems, commands, and button mappings) should be declared here.    """    def __init__(self) -> None:        # The robot's subsystems        self.robotDrive = DriveSubsystem()        self.limelight = LimelightCamera("limelight")        self.limelight.setPiPMode(2)        self.intake = Intake(leaderCanID=IntakeConstants.kLeadIntake, followerCanID=IntakeConstants.kFollowIntake,                             leaderInverted=False, followerInverted=True, rangeFinder=None)        self.singleIntake = SingleIntake(intakeCanID=IntakeConstants.kIntake)        self.elevator = Elevator(leadMotorCANId=LiftConstants.kLeadLift, followMotorCANId=LiftConstants.kFollowLift,                                 presetSwitchPositions=(0.1, 4.5, 12.51))        # The driver's controller        self.driverController = CommandGenericHID(OIConstants.kDriverControllerPort)        self.operatorController = CommandGenericHID(OIConstants.kOperatorControllerPort)        # Configure the button bindings and autos        self.configureButtonBindings()        self.configureAutos()        # Configure default command for driving using sticks        self.robotDrive.setDefaultCommand(            HolonomicDrive(                self.robotDrive,                forwardSpeed=lambda: self.driverController.getRawAxis(XboxController.Axis.kLeftY),                leftSpeed=lambda: self.driverController.getRawAxis(XboxController.Axis.kLeftX),                rotationSpeed=lambda: -self.driverController.getRawAxis(XboxController.Axis.kRightX),                deadband=OIConstants.kDriveDeadband,                fieldRelative=True,                rateLimit=True,                square=True,            )        )        self.elevator.setDefaultCommand(            commands2.RunCommand(                lambda: self.elevator.drive(self.operatorController.getRawAxis(XboxController.Axis.kLeftY)),                self.elevator)        )    def configureButtonBindings(self) -> None:        """        Use this method to define your button->command mappings. Buttons can be created by        instantiating a :GenericHID or one of its subclasses (Joystick or XboxController),        and then passing it to a JoystickButton.        """        def swerveSide(metersToTheLeft: float, metersBackwards: float, drivetrain: DriveSubsystem, speed=1.0,                       heading=None):            return SwerveMove(metersToTheLeft=metersToTheLeft, metersBackwards=metersBackwards, drivetrain=drivetrain,                              speed=speed, heading=heading) #By Jonas: I had to do this because when I used SwerveMove twice        #it would return errors.        # Driver Controller        povUpDriverButton = self.driverController.pov(0)        povUpDriverButton.onTrue(ResetXY(x=0.0, y=0.0, headingDegrees=0.0, drivetrain=self.robotDrive))        povUpDriverButton.whileTrue(RunCommand(self.robotDrive.setX, self.robotDrive))        povDownDriverButton = self.driverController.pov(180)        povDownDriverButton.onTrue(ResetSwerveFront(self.robotDrive))        bDriverController = self.driverController.button(XboxController.Button.kB)        FeedUpper = IntakeFeedGamepieceForward(self.intake, motor1speed=-0.5).withTimeout(1.0)        bDriverController.onTrue(FeedUpper)        xDriverButton = self.driverController.button(XboxController.Button.kX)        FeedLower = IntakeFeedGamepieceForward(self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        xDriverButton.onTrue(FeedLower)        leftDriverBumper = self.driverController.button(XboxController.Button.kLeftBumper)        setPipeline0 = SetCameraPipeline(camera=self.limelight, pipelineIndex=0)        followTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2,                                 stopWhen=StopWhen(maxSize=15))        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2)        swerveToLeft = swerveSide(metersToTheLeft=0.4, metersBackwards=-0.2, drivetrain=self.robotDrive, speed=0.5)        leftDriverBumper.whileTrue(setPipeline0.andThen(followTag).andThen(alignWithTag).andThen(swerveToLeft))        rightDriverBumper = self.driverController.button(XboxController.Button.kRightBumper)        setPipeline0 = SetCameraPipeline(camera=self.limelight, pipelineIndex=0)        followTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2,                                 stopWhen=StopWhen(maxSize=15))        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2)        swerveToRight = swerveSide(metersToTheLeft=-0.1, metersBackwards=-0.2, drivetrain=self.robotDrive, speed=0.5)        rightDriverBumper.whileTrue(setPipeline0.andThen(followTag).andThen(alignWithTag).andThen(swerveToRight))        # Operator Controller        leftOperatorBumper = self.operatorController.button(XboxController.Button.kLeftBumper)        leftOperatorBumper.onTrue(InstantCommand(self.elevator.switchUp, self.elevator))        rightOperatorBumper = self.operatorController.button(XboxController.Button.kRightBumper)        rightOperatorBumper.onTrue(InstantCommand(self.elevator.switchDown, self.elevator))        yOperatorButton = self.operatorController.button(XboxController.Button.kY)        singleIntakeCmd = IntakeGamepiece(self.singleIntake, speed=-0.4)        yOperatorButton.whileTrue(singleIntakeCmd)        xOperatorButton = self.operatorController.button(XboxController.Button.kX)        oppSingleIntake = IntakeGamepiece(self.singleIntake, speed=0.4)        xOperatorButton.whileTrue(oppSingleIntake)        aOperatorButton = self.operatorController.button(XboxController.Button.kA)        intakeCmd = IntakeGamepiece(self.intake, speed=-0.2)        aOperatorButton.whileTrue(intakeCmd)    def disablePIDSubsystems(self) -> None:        """Disables all ProfiledPIDSubsystem and PIDSubsystem instances.        This should be called on robot disable to prevent integral windup."""    def getAutonomousCommand(self) -> commands2.Command:        """        :returns: the command to run in autonomous        """        command = self.chosenAuto.getSelected()        return command()    def configureAutos(self):        self.chosenAuto = wpilib.SendableChooser()        # you can also set the default option, if needed        self.chosenAuto.setDefaultOption("Test Auto", self.getTestAuto)        self.chosenAuto.addOption("Blue 1 Difficult", self.getBlue1Difficult)        self.chosenAuto.addOption("Blue 2 Difficult", self.getBlue2Difficult)        self.chosenAuto.addOption("Blue 3 Difficult", self.getBlue3Difficult)        self.chosenAuto.addOption("Red 1 Difficult", self.getRed1Difficult)        self.chosenAuto.addOption("Red 2 Difficult", self.getRed2Difficult)        self.chosenAuto.addOption("Red 3 Difficult", self.getRed3Difficult)        self.chosenAuto.addOption("Blue 1", self.getBlue1)        self.chosenAuto.addOption("Blue 2", self.getBlue2)        self.chosenAuto.addOption("Blue 3", self.getBlue3)        self.chosenAuto.addOption("Red 1", self.getRed1)        self.chosenAuto.addOption("Red 2", self.getRed2)        self.chosenAuto.addOption("Red 3", self.getRed3)        wpilib.SmartDashboard.putData("Chosen Auto", self.chosenAuto)    def getTestAuto(self):        def roundHeading():            angle = self.robotDrive.getHeading().degrees()            result = 60 * round(angle / 60)            print(f"Rounded heading to {result} and angle is {angle}")            return result        startLocation = ResetXY(x=0, y=0, headingDegrees=0, drivetrain=self.robotDrive)        setPipeline3 = SetCameraPipeline(camera=self.limelight, pipelineIndex=3)        aimToSixty = AimToDirection(degrees=60, drivetrain=self.robotDrive)        approachTag = ApproachTag(camera=self.limelight, drivetrain=self.robotDrive, speed=1.0, pushForwardSeconds=None,                                      specificHeadingDegrees=roundHeading)        score = IntakeFeedGamepieceForward(self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        command = startLocation.andThen(setPipeline3).andThen(aimToSixty).andThen(approachTag).andThen(score)        return command    def getBlue1Difficult(self):        # Start to Reef        resetXY = ResetXY(x=8.000, y=1.000, headingDegrees=160.000, drivetrain=self.robotDrive)        setPipeline3 = SetCameraPipeline(camera=self.limelight, pipelineIndex=3)        findReefTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followReefTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2, stopWhen=StopWhen(maxSize=9))        alignReefTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2)        score = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        startToReef = resetXY.andThen(setPipeline3).andThen(findReefTag).andThen(followReefTag).andThen(alignReefTag).andThen(            score)        # Reef to Station        moveLeft = SwerveMove(metersToTheLeft=2, metersBackwards=0.0, drivetrain=self.robotDrive, speed=0.2)        setPipeline1 = SetCameraPipeline(camera=self.limelight, pipelineIndex=1)        findStationTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followStationTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2,                                        stopWhen=StopWhen(maxSize=9)  # line added by Gene                                        )        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2,                                    pushForwardSpeed=0.1, pushForwardSeconds=2.0)        turnToIntake = AimToDirection(degrees=40.000, drivetrain=self.robotDrive, speed=0.2)        intake = IntakeGamepiece(intake=self.intake, speed=0.5).withTimeout(1.5)        reefToStation = moveLeft.andThen(setPipeline1).andThen(findStationTag).andThen(followStationTag).andThen(            alignWithTag).andThen(turnToIntake).andThen(intake)        # Station to score        setPipeline4 = SetCameraPipeline(camera=self.limelight, pipelineIndex=4)        findScoreTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followScoreTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2,                                      stopWhen=StopWhen(maxSize=9))        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2,                                    pushForwardSeconds=2.0, pushForwardSpeed=0.1,)        scoreAgain = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        stationToScore = setPipeline4.andThen(findScoreTag).andThen(followScoreTag).andThen(alignWithTag).andThen(            scoreAgain)        command = startToReef.andThen(reefToStation).andThen(stationToScore)        return command    def getBlue2Difficult(self):        # Start to Reef        resetXY = ResetXY(x=8.000, y=4.000, headingDegrees=180.000, drivetrain=self.robotDrive)        setPipeline2 = SetCameraPipeline(camera=self.limelight, pipelineIndex=2)        findReefTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followReefTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignReefTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5, specificHeadingDegrees=120.0)        score = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        startToReef = resetXY.andThen(setPipeline2).andThen(findReefTag).andThen(followReefTag).andThen(alignReefTag).andThen(            score)        # Reef to Station        moveLeft = SwerveMove(metersToTheLeft=2, metersBackwards=0.0, drivetrain=self.robotDrive, speed=0.5)        setPipeline1 = SetCameraPipeline(camera=self.limelight, pipelineIndex=1)        findStationTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followStationTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        turnToIntake = AimToDirection(degrees=40.000, drivetrain=self.robotDrive, speed=0.5)        intake = IntakeGamepiece(intake=self.intake, speed=0.5).withTimeout(1.5)        reefToStation = moveLeft.andThen(setPipeline1).andThen(findStationTag).andThen(followStationTag).andThen(            alignWithTag).andThen(turnToIntake).andThen(intake)        # Station to score        setPipeline4 = SetCameraPipeline(camera=self.limelight, pipelineIndex=4)        findScoreTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followScoreTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        scoreAgain = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        stationToScore = setPipeline4.andThen(findScoreTag).andThen(followScoreTag).andThen(alignWithTag).andThen(            scoreAgain)        command = startToReef.andThen(reefToStation).andThen(stationToScore)        return command    def getBlue3Difficult(self):        # Start to Reef        resetXY = ResetXY(x=8.000, y=7.000, headingDegrees=180.000, drivetrain=self.robotDrive)        setPipeline3 = SetCameraPipeline(camera=self.limelight, pipelineIndex=3)        findReefTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followReefTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignReefTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5, specificHeadingDegrees=120.0)        score = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        startToReef = resetXY.andThen(setPipeline3).andThen(findReefTag).andThen(followReefTag).andThen(alignReefTag).andThen(            score)        # Reef to Station        moveRight = SwerveMove(metersToTheLeft=-2, metersBackwards=0.0, drivetrain=self.robotDrive, speed=0.5)        setPipeline1 = SetCameraPipeline(camera=self.limelight, pipelineIndex=1)        findStationTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followStationTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        turnToIntake = AimToDirection(degrees=40.000, drivetrain=self.robotDrive, speed=0.5)        intake = IntakeGamepiece(intake=self.intake, speed=0.5).withTimeout(1.5)        reefToStation = moveRight.andThen(setPipeline1).andThen(findStationTag).andThen(followStationTag).andThen(            alignWithTag).andThen(turnToIntake).andThen(intake)        # Station to score        setPipeline4 = SetCameraPipeline(camera=self.limelight, pipelineIndex=4)        findScoreTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followScoreTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        scoreAgain = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        stationToScore = setPipeline4.andThen(findScoreTag).andThen(followScoreTag).andThen(alignWithTag).andThen(            scoreAgain)        command = startToReef.andThen(reefToStation).andThen(stationToScore)        return command    def getRed1Difficult(self):        # Start to Reef        resetXY = ResetXY(x=10.000, y=7.000, headingDegrees=0.000, drivetrain=self.robotDrive)        setPipeline3 = SetCameraPipeline(camera=self.limelight, pipelineIndex=3)        findReefTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followReefTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignReefTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5, specificHeadingDegrees=120.0)        score = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        startToReef = resetXY.andThen(setPipeline3).andThen(findReefTag).andThen(followReefTag).andThen(alignReefTag).andThen(            score)        # Reef to Station        moveLeft = SwerveMove(metersToTheLeft=2, metersBackwards=0.0, drivetrain=self.robotDrive, speed=0.5)        setPipeline1 = SetCameraPipeline(camera=self.limelight, pipelineIndex=1)        findStationTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followStationTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        turnToIntake = AimToDirection(degrees=40.000, drivetrain=self.robotDrive, speed=0.5)        intake = IntakeGamepiece(intake=self.intake, speed=0.5).withTimeout(1.5)        reefToStation = moveLeft.andThen(setPipeline1).andThen(findStationTag).andThen(followStationTag).andThen(            alignWithTag).andThen(turnToIntake).andThen(intake)        # Station to score        setPipeline4 = SetCameraPipeline(camera=self.limelight, pipelineIndex=4)        findScoreTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followScoreTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        scoreAgain = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        stationToScore = setPipeline4.andThen(findScoreTag).andThen(followScoreTag).andThen(alignWithTag).andThen(            scoreAgain)        command = startToReef.andThen(reefToStation).andThen(stationToScore)        return command    def getRed2Difficult(self):        # Start to Reef        resetXY = ResetXY(x=10.000, y=4.000, headingDegrees=0.000, drivetrain=self.robotDrive)        setPipeline2 = SetCameraPipeline(camera=self.limelight, pipelineIndex=2)        findReefTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followReefTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignReefTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5, specificHeadingDegrees=120.0)        score = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        startToReef = resetXY.andThen(setPipeline2).andThen(findReefTag).andThen(followReefTag).andThen(alignReefTag).andThen(            score)        # Reef to Station        moveLeft = SwerveMove(metersToTheLeft=2, metersBackwards=0.0, drivetrain=self.robotDrive, speed=0.5)        setPipeline1 = SetCameraPipeline(camera=self.limelight, pipelineIndex=1)        findStationTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followStationTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        turnToIntake = AimToDirection(degrees=40.000, drivetrain=self.robotDrive, speed=0.5)        intake = IntakeGamepiece(intake=self.intake, speed=0.5).withTimeout(1.5)        reefToStation = moveLeft.andThen(setPipeline1).andThen(findStationTag).andThen(followStationTag).andThen(            alignWithTag).andThen(turnToIntake).andThen(intake)        # Station to score        setPipeline4 = SetCameraPipeline(camera=self.limelight, pipelineIndex=4)        findScoreTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followScoreTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        scoreAgain = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        stationToScore = setPipeline4.andThen(findScoreTag).andThen(followScoreTag).andThen(alignWithTag).andThen(            scoreAgain)        command = startToReef.andThen(reefToStation).andThen(stationToScore)        return command    def getRed3Difficult(self):        # Start to Reef        resetXY = ResetXY(x=10.000, y=1.000, headingDegrees=0.000, drivetrain=self.robotDrive)        setPipeline3 = SetCameraPipeline(camera=self.limelight, pipelineIndex=3)        findReefTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followReefTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignReefTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5, specificHeadingDegrees=120.0)        score = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        startToReef = resetXY.andThen(setPipeline3).andThen(findReefTag).andThen(followReefTag).andThen(alignReefTag).andThen(            score)        # Reef to Station        moveRight = SwerveMove(metersToTheLeft=-2, metersBackwards=0.0, drivetrain=self.robotDrive, speed=0.5)        setPipeline1 = SetCameraPipeline(camera=self.limelight, pipelineIndex=1)        findStationTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followStationTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        turnToIntake = AimToDirection(degrees=40.000, drivetrain=self.robotDrive, speed=0.5)        intake = IntakeGamepiece(intake=self.intake, speed=0.5).withTimeout(1.5)        reefToStation = moveRight.andThen(setPipeline1).andThen(findStationTag).andThen(followStationTag).andThen(            alignWithTag).andThen(turnToIntake).andThen(intake)        # Station to score        setPipeline4 = SetCameraPipeline(camera=self.limelight, pipelineIndex=4)        findScoreTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followScoreTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        alignWithTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.5)        scoreAgain = IntakeFeedGamepieceForward(intake=self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        stationToScore = setPipeline4.andThen(findScoreTag).andThen(followScoreTag).andThen(alignWithTag).andThen(            scoreAgain)        command = startToReef.andThen(reefToStation).andThen(stationToScore)        return command    def getBlue1(self):        startLocation = WaitCommand(0)  # placeholder, does nothing        # # if we set start location to be a real field location (including real correct gyro angle)        # startLocation = ResetXY(x=7.588, y=7.447, headingDegrees=-135)        #  (135 degrees: ^^ leftmost BLUE location on black line, aimed at nearest reef wall)        setPipeline = SetCameraPipeline(camera=self.limelight, pipelineIndex=3)        findTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.3,                                 stopWhen=StopWhen(maxSize=15))        alignTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2, pushForwardSeconds=0.5,                                pushForwardSpeed=0.2, detectionTimeoutSeconds=2.0, specificHeadingDegrees=180)        # # then we can use that robot gyro to demand a specificHeading (-120 degrees) when aligning with AprilTag        # alignTag = AlignWithTag(specificHeadingDegrees=-120,        #                        camera=self.limelight, drivetrain=self.robotDrive, speed=0.2, pushForwardSeconds=0.5,        #                        pushForwardSpeed=0.2, detectionTimeoutSeconds=2.0)        shootLower = IntakeFeedGamepieceForward(self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        command = startLocation.andThen(setPipeline).andThen(findTag).andThen(followTag).andThen(alignTag).andThen(shootLower)        return command    def getBlue2(self):        #startLocation = WaitCommand(0)  # placeholder, does nothing        # # if we set start location to be a real field location (including real correct gyro angle)        startLocation = ResetXY(x=7.189, y=4.025, headingDegrees=180, drivetrain=self.robotDrive)        #  (180 degrees: ^^ middle BLUE location on black line, aimed at nearest reef wall)        setPipeline = SetCameraPipeline(camera=self.limelight, pipelineIndex=2)        findTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.3,                                 stopWhen=StopWhen(maxSize=15))        alignTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2, pushForwardSeconds=0.4,                                pushForwardSpeed=0.2, detectionTimeoutSeconds=2.0, specificHeadingDegrees=180)        # # then we can use that robot gyro to demand a specificHeading (180 degrees) when aligning with AprilTag        # alignTag = AlignWithTag(specificHeadingDegrees=180,        #                        camera=self.limelight, drivetrain=self.robotDrive, speed=0.2, pushForwardSeconds=0.5,        #                        pushForwardSpeed=0.2, detectionTimeoutSeconds=2.0)        shootLower = IntakeFeedGamepieceForward(self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        command = startLocation.andThen(setPipeline).andThen(findTag).andThen(followTag).andThen(alignTag).andThen(shootLower)        return command    def getBlue3(self):        startLocation = ResetXY(x=8.000, y=7.000, headingDegrees=180, drivetrain=self.robotDrive)        setPipeline = SetCameraPipeline(camera=self.limelight, pipelineIndex=3)        findTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.3,                                 stopWhen=StopWhen(maxSize=15))        alignTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2, pushForwardSeconds=0.5,                                pushForwardSpeed=0.2, detectionTimeoutSeconds=2.0, specificHeadingDegrees=180)        shootLower = IntakeFeedGamepieceForward(self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        command = startLocation.andThen(setPipeline).andThen(findTag).andThen(followTag).andThen(alignTag).andThen(shootLower)        return command    def getRed1(self):        startLocation = WaitCommand(0)  # placeholder, does nothing        setPipeline = SetCameraPipeline(camera=self.limelight, pipelineIndex=3)        findTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.3,                                 stopWhen=StopWhen(maxSize=15))        alignTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2, pushForwardSeconds=0.5,                                pushForwardSpeed=0.2, detectionTimeoutSeconds=2.0)        shootLower = IntakeFeedGamepieceForward(self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        command = startLocation.andThen(setPipeline).andThen(findTag).andThen(followTag).andThen(alignTag).andThen(shootLower)        return command    def getRed2(self):        startLocation = WaitCommand(0)  # placeholder, does nothing        setPipeline = SetCameraPipeline(camera=self.limelight, pipelineIndex=2)        findTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.3,                                 stopWhen=StopWhen(maxSize=15))        alignTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2, pushForwardSeconds=0.5,                                pushForwardSpeed=0.2, detectionTimeoutSeconds=2.0)        shootLower = IntakeFeedGamepieceForward(self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        command = startLocation.andThen(setPipeline).andThen(findTag).andThen(followTag).andThen(alignTag).andThen(shootLower)        return command    def getRed3(self):        startLocation = WaitCommand(0)  # placeholder, does nothing        setPipeline = SetCameraPipeline(camera=self.limelight, pipelineIndex=3)        findTag = FindObject(camera=self.limelight, drivetrain=self.robotDrive)        followTag = FollowObject(camera=self.limelight, drivetrain=self.robotDrive, speed=0.3,                                 stopWhen=StopWhen(maxSize=15))        alignTag = AlignWithTag(camera=self.limelight, drivetrain=self.robotDrive, speed=0.2, pushForwardSeconds= 0.5)        shootLower = IntakeFeedGamepieceForward(self.intake, motor1speed=-0.5, motor2speed=-0.2).withTimeout(1.5)        command = startLocation.andThen(setPipeline).andThen(findTag).andThen(followTag).andThen(alignTag).andThen(shootLower)        return command    def getAutonomousTrajectoryExample(self) -> commands2.Command:        # Create config for trajectory        config = TrajectoryConfig(            AutoConstants.kMaxSpeedMetersPerSecond,            AutoConstants.kMaxAccelerationMetersPerSecondSquared,        )        # Add kinematics to ensure max speed is actually obeyed        config.setKinematics(DriveConstants.kDriveKinematics)        # An example trajectory to follow. All units in meters.        exampleTrajectory = TrajectoryGenerator.generateTrajectory(            # Start at the origin facing the +X direction            Pose2d(0, 0, Rotation2d(0)),            # Pass through these two interior waypoints, making an 's' curve path            [Translation2d(0.5, 0.5), Translation2d(1, -0.5)],            # End 1.5 meters straight ahead of where we started, facing forward            Pose2d(1.5, 0, Rotation2d(0)),            config,        )        thetaController = ProfiledPIDControllerRadians(            AutoConstants.kPThetaController,            0,            0,            AutoConstants.kThetaControllerConstraints,        )        thetaController.enableContinuousInput(-math.pi, math.pi)        driveController = HolonomicDriveController(            PIDController(AutoConstants.kPXController, 0, 0),            PIDController(AutoConstants.kPXController, 0, 0),            thetaController,        )        swerveControllerCommand = commands2.SwerveControllerCommand(            exampleTrajectory,            self.robotDrive.getPose,  # Functional interface to feed supplier            DriveConstants.kDriveKinematics,            driveController,            self.robotDrive.setModuleStates,            (self.robotDrive,),        )        # Reset odometry to the starting pose of the trajectory.        self.robotDrive.resetOdometry(exampleTrajectory.initialPose())        # Run path following command, then stop at the end.        return swerveControllerCommand.andThen(            cmd.run(                lambda: self.robotDrive.drive(0, 0, 0, False, False),                self.robotDrive,            )        )    def getTestCommand(self) -> typing.Optional[commands2.Command]:        """        :returns: the command to run in test mode (to exercise all systems)        """        return None